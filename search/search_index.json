{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83e\uddbe SCARA Robot Simulation Suite","text":"<p>Welcome to the documentation for the SCARA Robot Simulation &amp; Control Suite \u2014 a real-time simulation and control platform for SCARA-like parallel robots. This system supports both Software-in-the-Loop (SIL) and Hardware-in-the-Loop (HIL) workflows.</p>"},{"location":"#whats-inside","title":"\ud83d\ude80 What\u2019s Inside","text":"<ul> <li>\u2705 PyQt5 GUI with 3D visualization (via PyVista)</li> <li>\u2705 Symbolic dynamics using the Equivalent Point Mass (EPM) method</li> <li>\u2705 MPC and PID-based torque-level inverse dynamics control</li> <li>\u2705 Adaptive RK4 simulation and real-time fixed-step HIL</li> <li>\u2705 Cross-platform compatibility (Windows / Linux / macOS)</li> <li>\u2705 CSV-based trajectory buffering, export, and replay</li> </ul>"},{"location":"#documentation-topics","title":"\ud83d\udcd8 Documentation Topics","text":"<ul> <li>Read Me: Project setup and overview</li> <li>Control Architecture: Server loop, SIL/HIL logic, and PID/MPC control</li> <li>Kinematics &amp; Dynamics: Symbolic model, IK, Jacobians, and dynamic simplification</li> </ul>"},{"location":"#getting-started","title":"\ud83e\uddf0 Getting Started","text":"<p>To run the project:</p> <pre><code># Windows\nlauncher.bat\n\n# Linux/macOS\nchmod +x launcher.bash\n./launcher.bash\n</code></pre> <p>For development mode:</p> <pre><code>pip install -r requirements.txt\npython SCARA.py\n</code></pre>"},{"location":"#questions-or-feedback","title":"\ud83d\udceb Questions or Feedback?","text":"<p>Feel free to open an issue or discussion on the GitHub repository.</p> <p>\u00a9 2025 \u2013 SCARA Simulation &amp; Control Authors. MIT License.</p>"},{"location":"control/","title":"Control Architecture for SCARA Robot Simulation","text":""},{"location":"control/#overview","title":"Overview","text":"<p>The control system supports both Software-in-the-Loop (SIL) and Hardware-in-the-Loop (HIL) simulations with a client-server architecture:</p> <p>SIL: Pure software simulation for algorithm validation</p> <p>HIL: Real-time control with physical hardware interface</p> <p>Server: Handles trajectory processing and simulation</p> <p>Clients: GUI for visualization and embedded controller for HIL</p> <pre><code>graph TD;\n    A[GUI Client] --&gt;|Trajectory Data| B(main_server.cpp);\n    C[HIL Controller] --&gt;|Sensor Data| D(HIL.cpp);\n    B --&gt;D;\n    B --&gt;|Simulation Request| E(SIL.cpp);\n    E --&gt;|Results| B;\n    B --&gt;|Frames/Torques| A;\n    D --&gt;|Motor Commands| C;\n</code></pre>"},{"location":"control/#server-architecture-main_servercpp","title":"Server Architecture (main_server.cpp)","text":""},{"location":"control/#key-features","title":"Key Features:","text":"<p>TCP/IP Communication: Listens on port 5555 for client connections</p> <p>Chunked Data Transfer: Handles large trajectories in manageable chunks</p> <p>Cross-platform: Supports Windows (Winsock) and Linux/macOS (POSIX sockets)</p> <p>Parallel Processing: Spawns separate threads for each client</p> <p>Data Flow: </p> <ul> <li> <p>Receives trajectory waypoints + elbow configuration</p> </li> <li> <p>Validates trajectory size (prevents memory overflows)</p> </li> <li> <p>Passes data to SIL simulation engine</p> </li> <li> <p>Streams results back to client in binary format:</p> </li> <li> <p>Simulation frames (position, velocity, torque)</p> </li> <li> <p>Ideal torque points (for analysis)</p> </li> </ul> <p>Optimization:</p> <pre><code>constexpr size_t MAX_SOCKET_CHUNK = 10 * 1024 * 1024;  // 10MB chunks\nconstexpr size_t FRAME_CHUNK_SIZE = 500;  // Balance\n</code></pre>"},{"location":"control/#sil-simulation-pipeline-silcpp","title":"SIL Simulation Pipeline (SIL.cpp)","text":""},{"location":"control/#simulation-stages","title":"Simulation Stages:","text":"<p>Ideal Torque Precomputation:</p> <ul> <li> <p>Solves inverse kinematics for each waypoint</p> </li> <li> <p>Calculates inverse dynamics for ideal torque values</p> </li> </ul> <p>Adaptive RK4 Integration:</p> <ul> <li> <p>Uses error-controlled step sizing (Bogacki-Shampine method)</p> </li> <li> <p>Implements anti-windup for integral terms</p> </li> <li> <p>Handles singularities with damped pseudoinverse</p> </li> </ul> <pre><code>// Adaptive stepping parameters\n\ndouble dt = 0.001;\ndouble dt_min = 1e-6;\ndouble dt_max = 1e-2;\ndouble error_tol = 1e-3;&lt;/code&gt;\n</code></pre> <p>Real-time Constraints:</p> <pre><code> // Chunking\n\nconstexpr size_t MAX_FRAME_POINTS = 1000000;  // Memory safety\nif (results_out.size() &gt;= MAX_FRAME_POINTS) break;&lt;/code&gt;\n</code></pre>"},{"location":"control/#hil-controller-hilcpp","title":"HIL Controller (HIL.cpp)","text":""},{"location":"control/#embedded-friendly-design","title":"Embedded-Friendly Design:","text":"<p>Sensor Processing:</p> <ul> <li> <p>Spherical coordinate input (r, \u03b8, \u03c6)</p> </li> <li> <p>Low-pass filters for noise reduction</p> </li> <li> <p>Finite-difference velocity estimation</p> </li> </ul> <p>Real-time Loop:</p> <ul> <li> <p>Fixed-frequency execution (1kHz typical)</p> </li> <li> <p>Timing precision with std::chrono</p> </li> <li> <p>Overrun detection and logging</p> </li> </ul> <pre><code>// Timing control example\n\nauto loop_start = std::chrono::steady_clock::now();\n// ... control calculations ...\nauto loop_end = std::chrono::steady_clock::now();\nauto elapsed = ...;\nlong sleep_us = static_cast&lt;long&gt;(dt * 1e6) - elapsed.count();\nif (sleep_us &gt; 0) std::this_thread::sleep_for(...);\n</code></pre> <p>Fault Tolerance:</p> <ul> <li> <p>IK fallback to previous valid solution</p> </li> <li> <p>Torque limiting (\u00b1torque_limit)</p> </li> <li> <p>NaN detection in control outputs</p> </li> </ul> <p>Hardware Abstraction:</p> <pre><code>class HardwareInterface {\n\n public:\n    virtual SensorReading getSensorData() = 0;\n    virtual void sendMotorTorques(const Eigen::Vector3d&amp; torques)= 0;\n&gt;};\n</code></pre>"},{"location":"control/#dynamics-control-core","title":"Dynamics &amp; Control Core","text":""},{"location":"control/#robot-model-robotmodelcpp","title":"Robot Model (RobotModel.cpp)","text":"<p>Kinematics:</p> <ul> <li> <p>Analytical IK with configuration continuity</p> </li> <li> <p>Forward kinematics via geometric constraints</p> </li> <li> <p>Singularity-robust Jacobians</p> </li> </ul> <p>Dynamics:</p> <ul> <li> <p>Recursive Newton-Euler formulation</p> </li> <li> <p>Mass matrix with distributed inertia</p> </li> <li> <p>Gravity compensation with payload</p> </li> </ul>"},{"location":"control/#controller-controllercpp","title":"Controller (Controller.cpp)","text":"<p>Trajectory Interpolation:</p> <ul> <li> <p>Quintic Hermite splines for smooth motion</p> </li> <li> <p>C\u00b2 continuous position/velocity/acceleration</p> </li> </ul> <p>MPC Torque Computation:</p> <pre><code>Eigen::Vector3d Controller::computeMPCTorque(...) {\n  // PID error terms with anti-windup\n  integral_error += error_pos * dt;\n  integral_error = integral_error.cwiseMax(-integral_max).cwiseMin(integral_max);\n\n  // Task-space to joint-space conversion\n  Eigen::Matrix3d K_inv = robot.dampedPseudoInverse(K);\n  Eigen::Vector3d theta_ddot_desired = K_inv * (...);\n\n  // Dynamics compensation\n  Eigen::Vector3d tau = M * theta_ddot_desired + G;\n  return tau.cwiseMax(-torque_limit).cwiseMin(torque_limit);\n}\n</code></pre> <p>Performance Optimizations - Eigen Templates: Fixed-size matrices for stack allocation</p> <ul> <li> <p>Trajectory Caching: Precomputed ideal torques</p> </li> <li> <p>Batch Processing: Matrix operations instead of element-wise</p> </li> <li> <p>Algebraic Simplification: Precomputed EoM terms</p> </li> <li> <p>Memory Management: Reserved vectors with estimated capacity</p> </li> </ul> <p>Loop Control Strategies</p> System Control Method Frequency Real-time SIL Feedforward PID Adaptive RK4 Variable No HIL Feedforward PID Fixed-step MPC 1kHz fixed Yes <p>Key Metrics:</p> <p>SIL: 100-500\u03bcs per simulation step (depending on complexity)</p> <p>HIL: &lt;1ms total cycle time (sensor\u2192computation\u2192actuation)</p> <p>Embedded Design Choices</p> <ul> <li> <p>No Dynamic Allocation: Fixed-size arrays for critical paths</p> </li> <li> <p>FPU-Friendly: Single-precision floats where possible</p> </li> <li> <p>Sensor Filtering: Low-pass with O(1) complexity</p> </li> <li> <p>Hardware Abstraction: Portable interface layer</p> </li> <li> <p>Fault Recovery: Fallback to last valid state</p> </li> <li> <p>Efficient Trig: atan2 instead of manual quadrant checks</p> </li> </ul> <pre><code>// Embedded-friendly low-pass filter\nclass LowPassFilter {\npublic:\n    double filter(double new_value) {\n        value_ = alpha_ * new_value + (1 - alpha_) * value_;\n        return value_;\n    }\n};\n</code></pre>"},{"location":"control/#conclusion","title":"Conclusion","text":"<p>This architecture provides:</p> <ul> <li> <p>High-fidelity simulation for development (SIL)</p> </li> <li> <p>Deterministic real-time control (HIL)</p> </li> <li> <p>Cross-platform compatibility</p> </li> <li> <p>Memory-safe operation</p> </li> <li> <p>Embedded-ready implementation</p> </li> </ul> <p>The separation between simulation core and hardware interface enables seamless transition from virtual prototyping to physical deployment.</p>"},{"location":"kindyn/","title":"Kinematic and Dynamic Model of a Simplified 3-DOF SPARA Robot","text":""},{"location":"kindyn/#1-kinematics","title":"1. Kinematics","text":""},{"location":"kindyn/#structure","title":"Structure","text":"<ul> <li>Degrees of Freedom: Pure translational motion (x, y, z).    </li> <li>Actuators: 3 legs (Legs 1\u20133), with redundancy and rotational DOFs removed.    </li> <li>Key Changes from Original 4+1 DOF Design:    </li> <li>Suppressed redundant parameter <code>\u03b3</code> (Leg 5 replaced by 3).    </li> <li>Eliminated rotational DOF <code>\u03c6</code> (double parallelogram linkages removed).    </li> </ul>"},{"location":"kindyn/#simplified-jacobian-matrices","title":"Simplified Jacobian Matrices","text":"<p>Relate joint velocities to Cartesian velocities:   $$ \\mathbf{J} \\dot{\\mathbf{c}} = \\mathbf{K} \\dot{\\boldsymbol{\\theta}} $$ - Variables:     - $\\dot{\\mathbf{c}} = [\\dot{x}, \\dot{y}, \\dot{z}]^T$: End-effector translational velocities.     - $\\dot{\\boldsymbol{\\theta}} = [\\dot{\\theta}_1, \\dot{\\theta}_2, \\dot{\\theta}_3]^T$: Joint angular velocities.    </p>"},{"location":"kindyn/#singularities","title":"Singularities","text":"<ul> <li>Type I (Inverse Kinematics): Occurs when legs are fully extended/folded.    </li> <li>Type II (Forward Kinematics): Eliminated due to removed rotational constraints.    </li> </ul>"},{"location":"kindyn/#inverse-kinematics","title":"Inverse Kinematics","text":""},{"location":"kindyn/#joint-angle-expressions-theta_i","title":"Joint Angle Expressions $( \\theta_i )$","text":"<p>For legs $i = 1, 2, 3$:   $$ \\theta_i = 2 \\arctan\\left( \\frac{B_i \\pm \\sqrt{B_i^2 - (A_i + C_i)(C_i - A_i)}}{A_i + C_i} \\right) $$   Geometric Parameters:   For legs $i = 1, 2$: $$ \\begin{align} A_i &amp;= 2(a_{iy} - b_{iy}) \\ B_i &amp;= 2(b_{ix} - a_{ix}) \\ C_i &amp;= \\frac{\\ell_{i2}^2 - \\ell_{i1}^2 - (a_i - b_i)^T (a_i - b_i)}{\\ell_{i1}} \\end{align} $$  For leg $i = 3$: $$ \\begin{align} A_i &amp;= 2(a_{iz} - b_{iz}) \\ B_i &amp;= 2(b_{ix} - a_{ix}) \\ C_i &amp;= \\frac{\\ell_{i2}^2 - \\ell_{i1}^2 - (a_i - b_i)^T (a_i - b_i)}{\\ell_{i1}} \\end{align} $$ Variables:   - $a_i$ : Base joint position of leg $i$.   - $b_i$ : Distal joint position of leg $i$.   - $\\ell_{i1}, \\ell_{i2}$: Proximal/distal link lengths.    </p>"},{"location":"kindyn/#workspace","title":"Workspace","text":""},{"location":"kindyn/#translational-workspace","title":"Translational Workspace","text":"<ul> <li>Dimensions: ~0.5m \u00d7 1.0m \u00d7 0.3m (x, y, z).    </li> <li>Limits:    </li> <li>Determined by leg lengths ($\\ell_{i1}, \\ell_{i2}$).    </li> <li>Constrained by joint ranges (Fig. 10 in the paper).    </li> </ul>"},{"location":"kindyn/#performance","title":"Performance","text":"<ul> <li>Speed: Up to 3.5 m/s. </li> </ul>"},{"location":"kindyn/#velocity-equations","title":"Velocity Equations","text":""},{"location":"kindyn/#angular-velocity-dottheta_i","title":"Angular Velocity $\\dot{\\theta}_i$","text":"<p>Derived from Jacobian matrices:   $$ \\dot{\\boldsymbol{\\theta}} = \\mathbf{K}^{-1} \\mathbf{J} \\dot{\\mathbf{c}} $$    </p> <ul> <li>Original Paper:   L. -T. Schreiber and C. Gosselin, \"Sch\u00f6nflies Motion PARAllel Robot (SPARA): A Kinematically Redundant Parallel Robot With Unlimited Rotation Capabilities,\" in IEEE/ASME Transactions on Mechatronics, 2019.   DOI: 10.1109/TMECH.2019.2929646.</li> </ul>"},{"location":"kindyn/#2-dynamics","title":"2. Dynamics","text":""},{"location":"kindyn/#abstract","title":"Abstract","text":"<p>This simulation uses the Equivalent Point Mass (EPM) method \u2014 a simplified approach for dynamic modeling of parallel robots. The method replaces distal links with dynamically equivalent point masses at their endpoints, eliminating complex angular velocity calculations. Derived from Lagrangian mechanics, this technique is computationally efficient while maintaining good accuracy for slender links.</p>"},{"location":"kindyn/#equivalent-point-mass-epm-method","title":"Equivalent Point Mass (EPM) Method","text":""},{"location":"kindyn/#core-concept","title":"Core Concept","text":"<p>The EPM method simplifies dynamics by:</p> <ul> <li>Replacing distal links with point masses at their endpoints (B\u1d62 and C\u1d62)  </li> <li>Assigning masses based on energy equivalence principles  </li> <li>Handling potential and kinetic energy separately  </li> </ul>"},{"location":"kindyn/#mass-assignment-strategies","title":"Mass Assignment Strategies","text":"<p>For Potential Energy (exact equivalence):</p> <p>$$ m_{p1} = \\frac{m l_2}{l_1 + l_2}, \\quad  m_{p2} = \\frac{m l_1}{l_1 + l_2} $$</p> <p>Where ( l_1, l_2 ) are distances from the center of mass to the endpoints. For symmetric links:</p> <p>$$ m_{p1} = m_{p2} = \\frac{m}{2} $$</p> <p>For Kinetic Energy (approximate equivalence):</p>"},{"location":"kindyn/#fixed-mass-method","title":"Fixed Mass Method:","text":"<ul> <li>( m_{k1} = m_{k2} = \\frac{m}{2} ) (simple but less accurate)  </li> <li>or ( m_{k1} = \\frac{m}{3}, \\quad m_{k2} = \\frac{2m}{3} ) (better for rotational inertia)</li> </ul>"},{"location":"kindyn/#variable-mass-method-higher-accuracy","title":"Variable Mass Method (higher accuracy):","text":"<p>$$ \\begin{align} m_{k1} &amp;= \\frac{m}{3}(1 + k_1) \\ m_{k2} &amp;= \\frac{m}{3}(1 + k_2) \\end{align} $$</p> <p>With ( k )-coefficients calculated via minimum-norm solution:</p> <p>$$ k_1 = \\frac{|\\mathbf{v}_1|^2}{|\\mathbf{v}_1|^4 + |\\mathbf{v}_2|^4} \\mathbf{v}_1^T \\mathbf{v}_2, \\quad k_2 = \\frac{|\\mathbf{v}_2|^2}{|\\mathbf{v}_1|^4 + |\\mathbf{v}_2|^4} \\mathbf{v}_1^T \\mathbf{v}_2 $$</p>"},{"location":"kindyn/#dynamic-model-implementation","title":"Dynamic Model Implementation","text":""},{"location":"kindyn/#energy-formulation","title":"Energy Formulation","text":"<p>Kinetic energy for distal links simplifies to:</p> <p>$$ T_{\\text{EPM}} = \\frac{1}{2} (m_{k1} \\mathbf{v}1^T \\mathbf{v}_1 + m{k2} \\mathbf{v}_2^T \\mathbf{v}_2) $$</p>"},{"location":"kindyn/#actuator-torques","title":"Actuator Torques","text":"<p>Total torque combines contributions from:</p> <p>Proximal links (joint space):</p> <p>$$ \\boldsymbol{\\tau}_a = \\frac{d}{dt}\\left( \\frac{\\partial T}{\\partial \\dot{\\boldsymbol{\\theta}}} \\right) - \\frac{\\partial T}{\\partial \\boldsymbol{\\theta}} + \\frac{\\partial V}{\\partial \\boldsymbol{\\theta}} $$</p> <p>Platform + distal points (Cartesian space):</p> <p>$$ \\mathbf{f} = \\frac{d}{dt}\\left( \\frac{\\partial T}{\\partial \\dot{\\mathbf{p}}} \\right) - \\frac{\\partial T}{\\partial \\mathbf{p}} + \\frac{\\partial V}{\\partial \\mathbf{p}} $$</p> <p>Total actuator torque:</p> <p>$$ \\boldsymbol{\\tau} = \\boldsymbol{\\tau}_a + (\\mathbf{J}^{-1}\\mathbf{K})^T \\mathbf{f} $$</p>"},{"location":"kindyn/#advantages-limitations","title":"Advantages &amp; Limitations","text":""},{"location":"kindyn/#advantages","title":"\u2714\ufe0f Advantages","text":"<ul> <li>Eliminates complex angular velocity calculations  </li> <li>Reduces computational cost by 30\u201360% vs exact models  </li> <li>Maintains &gt;95% accuracy for slender links  </li> <li>Fixed mass method enables real-time control  </li> <li>Variable mass improves accuracy for known trajectories  </li> </ul>"},{"location":"kindyn/#limitations","title":"\u274c Limitations","text":"<ul> <li>Accuracy decreases for thick/rotating links  </li> <li>Fixed masses: limited accuracy across configurations  </li> <li>Variable masses: requires known trajectories  </li> <li>Potential energy: exact only when COM lies on link axis  </li> </ul>"},{"location":"kindyn/#performance-comparison","title":"Performance Comparison","text":"Method Comp. Cost Torque RMSE Best For Fixed Mass EPM Lowest 5\u20136 Nmm Real-time control Variable Mass Medium 2\u20133 Nmm Known trajectories Slender Link* High 0.4 Nmm General-purpose <p>* Reference method from original paper</p>"},{"location":"kindyn/#conclusion","title":"Conclusion","text":"<p>The EPM method provides an effective balance between accuracy and computational efficiency. For real-time control, fixed masses (( m/2 ) or ( m/3 + 2m/3 )) are recommended. For trajectory-based tasks, variable masses offer superior accuracy with moderate computation overhead.</p> <ul> <li>Original Paper:    Zhou Z., Gosselin C. (2024) Simplified Inverse Dynamic Models of Parallel Robots Based on Lagrangian Approach. Meccanica, 59:657\u2013680. DOI: 10.1007/s11012-024-01782-6</li> </ul>"}]}